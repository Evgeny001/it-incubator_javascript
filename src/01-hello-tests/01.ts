// const ругается, т.к TS требует, что бы из каждого файла что-то экспортировалось, что бы не писать этот экспорт
//в tsconfig.json в "isolatedModules": false,": true, поменять на false
const sentense = "Hello my friends!"   //написать функцию, которая будет дробить эти предложения на слова
// export const splitIntoWords =  (sentense: string)  => {
//      return (
//          ["Hello" , "my", "friends" ]
//      )
// }
export const splitIntoWords =  (sentense: string)  => {        //1. объявили функцию в параметры функции приходит sentense: string
    const words = sentense.toLowerCase().split(" ")
    return words.filter(w => w !== "" && w !== "-")
        .map(w=>w
            .replace("!", "")
            .replace(".", "")
            .replace(",", "")
        )
}
const result = splitIntoWords(sentense)                  //2. Вызвали эту функцию (что-бы проверить как она работает)
//Для этого объявили переменную и присвоили ей результат выполнения функции splitIntoWords, которую вызываем с помощью круглых скобок
// внутри круглых скобок пишем аргументы.
export const sum = (a: number, b: number) => {
    return a + b
}
export const mult = (a: number, b: number) => {
    return a * b
}
//протестируем функцию sum и mult
//1.Что бы тестировать какой-то файл, надо радом с этим файлом создать аналогичный файл, только перед ts/js написать слово test
//есть логика в одном файле и ее хотим протестировать с помощью unit-tests
//2.Используем функцию test в скобках в строке имя теста, вторым параметром функция, которая и будет являться тестом
//в ней будет логика тестирования
//этой функции сначала идет подготовительная часть - это исходные данные - data
//далее идут действия action - создается переменная и в нее записывается результат вызова функции, которую тестируем,
//в аргументы передаем данные из data.
//3 часть тесте expect result туда пишем еще одну функцию expect которую берем из среды JS - и в нее пишем,
//что мы ожидаем от переменной которую указали в action т.е. от result1 (в нашем случае expect(result1).toBe(3))
//чтобы запустить test: в терминале прописать npm/yarn test или во вкладке npm нажать test
// или отдельно протестировать данный test в файле, где test написан
//чем тест меньше т.е в нем меньше action тем лучше, лучше много независимых коротких тестов, чем один тест который тестирует все
//если делаем несколько action то создается несколько переменных
//когда test запустили, он дальше работает в автоматическом режиме, в режиме test watcher и когда мы делаем изменения в коде,
// test автоматически запускается, тесты не дают ошибиться, и те тесты, которые мы пишем остаются навсегда
// это называется покрытие кода тестами и чем больше покрытие кода тестами тем лучше
// тесты ускоряют разработку программ т.к. благодаря тестам мы можем проверить правильность работы нашей функции, в любой момент времени
// в отличии от мануального разового тестирования
// тест состоит из 3 этапов: 1. data (подготовительные данные). 2. action (действия). 3. expect result (ожидаемый результат)
//Фишка тестов: в функции можно писать что угодно, и тести это проверят на всех сценариях которые заранее
//были подготовлены.
//можно запустить тест в режиме debug, и файле в котором пишем код поставить точку останова, программа в данной точке остановится,
//пойти дальше - step over, можно наводить и смотреть что приходит в какую переменную
//step into прыгнуть внутрь функции
//часто пишут тесты на одну и ту же функцию или на сходные функции ==> исходная data будет повторяться, что бы избежать
//дублирование кода общий набор данных можно вынести за приделы кода, но нельзя писать четкие числа, так как когда
//тесты запускаются по очереди, какой-нибудь тест может случайно испортить глобальную переменную передав новое значение
//внутри себя, взяв переменную из замыкания сверху (глобальнее), следующий за этим тест уже будет работать некорректно
//т.е кокой-то из тестов во время своего выполнения испортил общий тестовый набор данных
//для этого начальный тестовый набор данных определяют без значений let a: number; let b: number; let c: number;
//перед тем как тестовая среда будет запускать тест указывают, что перед каждым тестом выполнить функцию beforeEach,
//которая вызывает callback функцию, которая присваивает указанные в callback значения для переменных a,b,c.
//например a = 1; b = 2; c = 3; если например тест внутри себя изменил значения a или b, что бы проверить как все работает,
//и глобальная a станет другим значением, перед запуском нового теста запуститься функция beforeEach и
//с помощью callback вернет значения переменным на исходные например: a = 1; b = 2; c = 3 как и было до первого теста.

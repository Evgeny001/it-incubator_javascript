//predicate функция, которая возвращает true or false, в параметры к ней будут приходить элементы массива - это возраста,
//если age > 91, то результат этого выражения true и элемент попадет в результирующий массив.
//В качестве примера: если predicate на условие скажет true, то пойдешь в одну комнату, если скажет false, то в другую
//функцию predicate надо будет запускать для каждого элемента массива ages, то что true попадает в результирующий массив,
//false пролетает и элемент не попадает в новый результирующий массив.
//Фильтрация работает следующим образом: на входе стоит чувак - predicate-функция и он говорит, что буду вызываться
//для каждого элемента массива, переданного в аргументы и буду проверять условие если true пропущу дальше если false, то нет.
//Для этого есть специальный метод массива filter.
//Метод filter - для исходного массива вызываем метод filter (массив является объектом ==> filter - это метод объекта).
//Функция, которая принадлежит объекту - называется метод. В метод засовываем другую функцию predicate, которая в
//параметры принимает элементы такого же типа как элементы массива. Функция predicate на основе какого-то своего анализа
//должна вернуть true или false. Если true, то элемент пойдет дальше, если false, то нет. Для функций predicate надо использовать
//стрелочные функции и так как очень часто в таких функциях нет никакой логики кроме возврата какого-то значения (перед return
//нет логики), то синтаксис стрелочной функции можно упростить.
//Удалить слово return и фигурные скобки, записав все в одну строчку: const predicate = ((age: number) => age > 90)
//(Если в стрелочной функции после стрелки нет фигурных скобок, то все что после стрелки возвращается как результат функции).
//Убираем return и {}, возврат значения после =>.
//В настоящей жизни функция predicate не создается как отдельная функция, а чаще всего это функция засовывается прямо
//внутрь метода filter const oldAges2 = ages.filter((age: number) => age > 90) - если age > 90 вернется true ==> попадет в массив
//Если пробегаемся по массиву например ages и TS знает, что там сидят числа, в параметре стрелочной функции можно убрать
//number и в этом случае можно убрать скобки, где указывают параметры функции const oldAges2 = ages.filter(age => age > 90).
//Когда функцию predicate мы засовываем внутрь метода filter, то TS понимает, что параметр этой функции - это элемент массива,
//поэтому описывать тип параметра через двоеточие в скобках не нужно и скобки в этом случае можно убрать.
//Метод filter пробегись по всем courses, каждый курс придет в тебя в course - в функцию-predicate, если price < 160, то
//пропусти в результат cheapCourses: const cheapCourses = courses.filter(course => course.price < 160).
//Внутрь filter передаем функцию, которая вызывает каждый элемент и определяет, идет он в результирующий массив или нет.
const ages = [18, 20, 22, 1, 100, 90, 14]
const predicate = (age: number) => {
    return age > 90
}

const oldAges = []   //> 90

type CourseType = {
    title: string,
    price: number
}
const courses: CourseType[] = [
    {title: 'css', price: 110},
    {title: 'JS', price: 200},
    {title: 'React', price: 150}
]
//160
const cheapPredicate = (course: CourseType) => {
    return course.price < 160
}

const cheapCourses = [
    {title: 'css', price: 110},
    {title: 'React', price: 150}
]

//Функция умеет выполнять кае-то действия ==> функцию можно вызывать и она будет постоянно производить эти действия,
//функция принимает параметры, что бы производить одинаковые действия в разными вещами, вещи прокидываем через параметры
//внутрь функции. 
//Самая простая функция: которая суммирует числа a+b. Если бы функция суммировала постоянная 2 одинаковых числа от нее
//бы было мало толку ==> функция нужна, что бы делать одно и то же действие, но с разными субъектами
//над кем действия производятся.
//Есть абстрактные переменные a, b и вызывая sum, в параметры дать конкретные значения и на основании их будет построен результат.
//Если в функции есть return это значит, что во время вызова функции (вызов функции - это имя функции и скобки
//(пример sum()),то в этом месте появится значение которое эта функция возвращает - return.
//Это значит, что в res запишется, то что возвращает (return) функция sum ==> const res = sum(1,3) (в данном случае в res будет 5)

import {StydentType} from "../02-Object/02";
import {CityType, GovermentBuildingsType, HousesType} from "./03_02.test";

export const sum = (a: number, b: number) => {
  return a + b
}
export function sum2 (a: number, b: number) {
    return a + b
}
const res = sum(1,3)
const res2 = sum(3,3)
//В качестве аргументов внутри функции можем засунуть вызов другой функции.
//Чтобы вызвать внешнюю функции sum, нужно сначала вызвать функции которые находятся в аргументах и получить от них значения
//мыслить так, что бы изнутри идти наружу
const res3 = sum(sum(1,3), sum(3,4))

//Чаще всего функции принимают в параметры не примитивные значения, а другие объекты.
//Напишем функцию, которая будет добавлять студенту новый technologies. В параметры передаем student: StydentType и
//technologies:string.
//В теле функции берем объект student, который передали в параметры и у него берем свойство technologies
//и методом массива push добавим новый объект созданный внутри функции, в свойство title передать technologies полученный
//из параметров.
//Если функция явно ничего не return, то в результате вызова undefined.
//Функции addSkill не надо ничего возвращать, она модифицирует те данные, которые в не приходят.
//Например: в addSkill пришел объект student и с ним внутри функции происходят преобразования, результата не ждем.
//Есть 2 мира в одном мире говорят функция, что можно брать объект и его модифицировать - это ООП мир.
//Мир функционального программирования говорит, что функции должны быть чистыми. Не имеем право менять, то, что в них пришло.
//Если функция не имеет право ничего менять, что бы от функции был какой-то толк она обязано что-то вернуть ==> return.
//Название параметра в функции - название переменной, это то как объект зовут внутри функции, во внутреннем миро данной функции.
//Во время вызова функции берем в нее значение и это же значение приходит внутрь функции, это значение можно называть как угодно,
//но работать будем с данными из переменной которую написали в аргументе во время вызова.
//Если это объект, то когда функция отрабатывает, то все равно изменяется объект, который находится в памяти,
//просто на него есть несколько ссылок.
//Во время вызова функции его зовут одним именем, а внутри функции может быть свое локальное имя, но обозначающее именно,
//то что передали во время вызова!
//Правило (TDD) test driven development - сначала тест, а потом удовлетворить, тест написанием функции.
//Создать функцию, которая будет получать на входе студента, если он живет в каком-то городе, то будет возвращать true,
//если нет, то false.
//Вызывая функцию doesStudentLivesIn получаем результат: сравнения города, который записан в объекте с тем, что пришло
//в аргументе.  Результат в виде true или false записывается в переменную которой присваиваем вызов функции (result1 и result2)
//(т.е. функция изучает объект student и сравнивает с переданным городом и если города одинаковы возвращает true).
//В expect описываем, что expect(result1).toBe(false) / expect(result2).toBe(true).
//Создаем функцию в которую приходит student и cityName, в теле функции будем сравнивать равен ли город внутри объекта student,
//cityName переданный в параметры.
//Функция doesStudentLivesIn обязана, что-то вернуть и она уже подходит под понятие чистых функций - она ничего
//не делает со входящими данными, а только анализирует, считывает и возвращает результат.
//Чистая функция обязана что-то return так как не имеет права ничего менять.

export const addSkill = (student: StydentType,technologies: string ) => {
   student.technologies.push({
       id: new Date().getTime(),
       title: technologies})
}

export const makeStudentActive = (student: StydentType ) => {
    student.isActive = true
}

export const doesStudentLivesIn = (student: StydentType, cityName: string ) => {
    return student.address.city.title === cityName;
}

export const addmoneyToBudget = (govermentBuildings: GovermentBuildingsType, money: number) => {
  govermentBuildings.budget += money

}

export const repairHouse = (houses: HousesType) => {
    houses.repaired = true
}

export const toFireStaff = (govermentBuildings: GovermentBuildingsType, staff: number) => {
     govermentBuildings.staffCount -= staff
}
export const toHireStaff = (govermentBuildings: GovermentBuildingsType, staff: number) => {
    govermentBuildings.staffCount += staff
}
export const createMessage = (city: CityType) => {
   // return city.title = "Hello New York. I want you be happy"
   // return  "Hell" + city.title + "citizens. I want you be happy. All" + city.citizensNumber + "men"
   return  `Hello ${city.title} citizens. I want you be happy. All ${city.citizensNumber} men`
}
// вместо того чтобы делать конкатенацию строк можно использовать обратные кавычки, а внутри знак доллара и в
//фигурных скобках вставлять, то что нам нужно.`Hell${city.title}citizens. I want you be happy. All${city.citizensNumber}men`

//Функции кусок кода, который хотим выполнять многократно с разными вещами.
//Функция принимает параметры, что бы можно было делать одно и то же действие с разными значениями,
//которые придут в параметры.
//Чаще всего внутрь функции будем помещать объекты, когда объект засовываем в аргумент
//(иногда достаем по индексу из массива) этот же объект приходит в параметры функции,
//важно чтобы типизация совпадала с тем, что в аргументах и то как типизированы параметры во время объявления
//функции, так как это одни и те же данные.
//В React и функциональном программировании чаще всего функции не имеют право менять объекты, и что бы их менять
//нужно применять концепции поверхностного / полного копирования.

//Объект people трансформировался в объект devs и всем этим занималась функция dimychTransformator. На входе функция
//получает объект man из массива people - это каждый отдельный человек (каждый элемент массива people - это объект) и
//возвращает какой-то другой объект.
//Миссия функции dimychTransformator в параметры получать один объект, а возвращать новый измененный объект на основании
//старого. Функция dimychTransformator вызывается для каждого элемента массива и в аргументы по очереди передается каждый
//элемент массива - это объект и на его основании возвращается новый объект.
//Если мы вызываем функцию, то на месте вызова этой функции появляется тот объект, который она возвращает.
export type ManType = {
    name: string
    age: number
}
export const people: ManType[] = [
    {name: 'Andrey Ivanov', age: 33},
    {name: 'Alexander Petrov', age: 24},
    {name: 'Dmitry Sidorov', age: 18},
]
//Если стрелочная функция ничего не делает кроме return, то можно удалить фигурные скоби и return.
//Фигурные скобки означают тело функции, но если как токового тела нет, а функция просто что-то return, то скобки можно
//убрать и убрать return. Если случай, что возвращаем объект, убрали return и {}, но остались одни {} в этом случае
//интерпретатор JS не может понять это скобки объекта или функции и в этом случае добавить круглые скобки перед {}.
const dimychTransformator = (man: ManType ) =>
    ({
        stack: ['css', 'html', 'js', 'tdd', 'react'],
        firstName: man.name.split(' ')[0],
        lastName: man.name.split(' ')[1]
    })

const devs = [
    {
        stack: ['css', 'html', 'js', 'tdd', 'react'],
        firstName: 'Andrey', lastName: 'Ivanov'
    },
    {
        stack: ['css', 'html', 'js', 'tdd', 'react'],
        firstName: 'Alexander', lastName: 'Petrov'
    },
    {
        stack: ['css', 'html', 'js', 'tdd', 'react'],
        firstName: 'Dmitry', lastName: 'Sidorov'
    },
]
let d1 = dimychTransformator(people[0])
let d2 = dimychTransformator(people[1])
let d3 = dimychTransformator(people[2])
//В массив devs2 поместим переменные d1, d2, d3, где сидят объекты, которые родились из функции dimychTransformator после
//ее вызова, когда она вернула разные значения в зависимости от переданных ей аргументов. Каждый созданный функцией объект
//создавался на основе старого объекта переданного в аргументы функции во время вызова.
const devs1 = [
    d1, d2, d3
]
//Можно в качестве элементов массива передать вызовы функций и на месте вызовов функций появится то что функция возвращает
//- это объект, который сразу будет помещен в массив.
const devs2 = [
    dimychTransformator(people[0]),
    dimychTransformator(people[1]),
    dimychTransformator(people[2])
]
//devs, devs1, devs2 - 3 массива одинаковых по содержанию, просто результат получен разными способами.
//Задача вызывать dimychTransformator для каждого элемента в массиве. Делается это следующим образом:
const devs3 = people.map(dimychTransformator)
//Метод map выкидывает новый массив, который появится после вызова функции (метода map) и присваивается в переменную devs3.
//В devs3 будут сидеть элементы полученные на основе элементов массива people. Метод map пробежит по каждому элементу people
//и для каждого элемента вызовет функцию dimychTransformator, которая передается внутрь метода map.
//Во время вызова dimychTransformator в каждый вызов в аргументы по очереди передаются элементы массива, а то что функция
//возвращает, то записывается новым элементом в новом массиве.
//Функции-трансформаторы не записываю как отдельные функции, а передают сразу внутрь map. Так как функция сразу
//закидывается внутрь map можно убрать типизацию параметра функции-трансформатора, и скобки в которых описываются параметры
//функции. В результирующем массиве столько же элементов сколько и в исходном. Для каждого элемента исходного массива создается
//какая-то альтернатива, функция запускается столько раз сколько элементов в исходном массиве.
//map преобразовывает один тип данных, который сидит в исходном массиве в другой, объект/строку/число/может преобразовать
//во все что угодно, трансформирует входящий массив во что угодно другое, главное, что количество элементов в массиве сохраняется.
//Результат отработки map - это всегда массив и в новом массиве сидит столько же элементов сколько и было и в исходном.
const devs4 = people.map(man => ({
    stack: ['css', 'html', 'js', 'tdd', 'react'],
    firstName: man.name.split(' ')[0],
    lastName: man.name.split(' ')[1]
}) )
//Получить из 3 объектов массива people массив с 3 текстовыми сообщениями
export const messages = people.map(man => `Hello ${man.name.split(' ')[0]}. Welcome to IT-Incubator`)

//Создать отдельную функцию, что бы часть логики упаковать в функцию и потом вызывать функцию в тесте.
export const createGreetingMessage = (people: ManType[]) => {
    return people.map(man => `Hello ${man.name.split(' ')[0]}. Welcome to IT-Incubator`)
}
